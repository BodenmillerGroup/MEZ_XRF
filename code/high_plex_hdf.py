# -*- coding: utf-8 -*-
"""
Created on Mon Jun  7 08:42:25 2021

This module contains the `HighPlexHdf` class for processing high multiplex, 
multichannel images alongside their associated masks and metadata. The class 
is designed to keep related image stacks and masks together in a format readily 
exported to hdf for storage. 

Besides exporting to hdf, the class structure simplifies the task of 
processing of any named image stack with any named mask. For instance, image 
channel measurements of cells in a cell mask, or nuclei in a nuclear mask.

High multiplex image stacks are stored in a `HighPlexHdf.images` dictionary. 
Multiple related datsets (e.g. raw and normalised image stacks) can be stored
in the `HighPlexHdf.images` dictionary. Relevant dataset names should be used 
as dictionary keys (e.g. 'raw' or 'normalised'), with image stacks being 
dictionary values in 3D numpy array [x, y, c] form. All stored image stacks 
should have the same [x, y, c] dimensions. 

Masks relevant to `HighPlexHdf.images` are stored in a `HighPlexHdf.masks` 
dictionary. Relevant mask names should be used as dictionary keys (e.g. 
'cell_mask' or 'nuclei_mask'), with masks being dictionary values in 2D numpy
array [x, y] form. Mask [x, y] dimensions need to match `HighPlexHdf.images` 
[x, y] dimensions.

Masks can be generated externally and directly added to `HighPlexHdf.masks`. 
Masks can also be generated using built in class functions. For instance, cell
and nuclear segmentation masks can be generated with the mesmer segmentation 
model from the Deepcell package. Masks generated by class functions are 
automatically added to `HighPlexHdf.masks`.

The `HighPlexHdf` class is useful for functions reliant on both an image stack
and mask. For instance, using a cell segmentation mask to measure intensities 
per cell across different image channels. Generating an anndata object from a 
named `HighPlexHdf.images` stack with a named `HighPlexHdf.images` mask, ensures 
the exported `high_plex_hdf.h5` image and mask from which anndata is derived is 
included in anndata[uns][high_plex_hdf_paths]. This simplifies linking anndata 
generated cell annotations (e.g. cell clusters) back to the source images and
masks from which original measurements were made (useful for mask visualisation
of annotations). 

@author: MerrickS
"""
import pathlib

import h5py
import numpy as np
import pandas as pd
import anndata as ad

from utilities import aggregate_images, rand_cmap
import matplotlib.pyplot as plt
from matplotlib_scalebar.scalebar import ScaleBar

from sklearn.metrics import adjusted_rand_score, adjusted_mutual_info_score, jaccard_score
from deepcell.applications import Mesmer
from deepcell.utils.plot_utils import create_rgb_image, make_outline_overlay

from steinbock.measurement.data import measure_intensites, measure_regionprops, Measurement
import steinbock.measurement.distances
 
from skimage.measure import regionprops_table


def hdf_to_HighPlex_Hdf(hdf_fpath):
    """
    Provided the path to an hdf file, this function reads that hdf files with
    HighPlexHdf structure back into the HighPlexHdf class.
    """
    sample_metadata = {}
    masks = {}
    images = {}

    with h5py.File(hdf_fpath, 'r') as hdf:
        # import relevant sample metadata
        for sample_info in hdf:
            if isinstance(hdf[sample_info], h5py._hl.dataset.Dataset):
                sample_metadata[sample_info] = hdf[sample_info][()]

        # import image stacks
        image_node = 'images'
        for image in hdf[image_node]:
            image_sub_node = f'{image_node}/{image}'
            if isinstance(hdf[image_sub_node], h5py._hl.dataset.Dataset):
                images[image] = hdf[image_sub_node][()]

        # import masks
        masks_node = 'masks'
        for mask in hdf[masks_node]:
            masks_sub_node = f'{masks_node}/{mask}'
            if isinstance(hdf[masks_sub_node], h5py._hl.dataset.Dataset):
                masks[mask] = hdf[masks_sub_node][()]

    channel_metadata = pd.read_hdf(hdf_fpath, key='images/df_channel_metadata')
    
    return HighPlexHdf(
        sample_metadata, 
        images, 
        channel_metadata, 
        masks, 
        hdf_fpath=hdf_fpath
    )

class HighPlexHdf:
    """
    HighPlexHdf is a class container for high multiplex images [x, y, channel]
    and their associated masks [x, y]. The container is designed to store image
    and mask datasets, image metadata and channel relevent information. The 
    class can be exported to an `.hdf` file for storage before downstream 
    processing. This class format has associated image and mask processing 
    functions such as mesmer segmentation, which are based on stored images, 
    masks and channel information. 
           
    Images and masks are stored as dictionaries of array datasets. This means 
    multiple related images (e.g. raw and normalised image stacks) can be 
    stored alongside multiple masks (which might identify different features). 
    Images and masks are exported as array datasets to 'images' and 'masks' 
    groups respectively in the exported hdf. 
    
    Image channel information is stored as a `pandas.Dataframe`, where 
    row index corresponds to an image channel [x, y, index]. In this manner, 
    channel related information can be intuitively stored in a columnwise 
    fashion. Examples of useful channel information to store in different 
    columns include different channel names relevent to experiment design 
    (e.g. the marker or tag present in an image channel) or columns indicating
    whether a channels relevent to downstream analyses (e.g. whether a channel
    should be used for cell/nuclear segmentation). The channel information 
    `pandas.Dataframe` is written (and read from) the export hdf with the 
    native pandas function. 
    
    The class can also handle cell and nuclei segmentation using mesmer. It can
    also generate refined matched cell and nuclear masks. 
    
    """
    def __init__(self, sample_metadata, images, channel_metadata, masks={}, hdf_fpath=None):
        self.fpath = hdf_fpath
        self.sample_metadata = sample_metadata
        self.images = images
        self.channel_metadata = channel_metadata
        self.masks = masks
                
    def get_channel_image(self, channel_name, image_name='raw'):
        idx = self.channel_metadata.loc[self.channel_metadata['plot_channel'] == channel_name].index
        image = self.images[image_name][:, :, idx]
        return image
    
    def cell_channel_img(self, image_name='raw'):
        self.cell_channels = self.channel_metadata.loc[self.channel_metadata['cell_segment'] == 1]
        img_idx = list(self.cell_channels.index)
        self.cell_avg_channel = aggregate_images(
            image_stack = self.images[image_name], 
            img_idx=img_idx, 
            agg_function='mean'
        )
    
    def nuclear_channel_img(self, image_name='raw'):
        self.nuclear_channels = self.channel_metadata.loc[self.channel_metadata['nuclear_segment'] == 1]
        img_idx = list(self.nuclear_channels.index)
        self.nuclear_avg_channel = aggregate_images(
            image_stack = self.images[image_name], 
            img_idx=img_idx, 
            agg_function='mean'
        )
    
#     REMOVED PLOT CHANNEL CALL, SHOULD STILL WORK BUT HERE IN CASE NOT
#     def cell_channel_img(self, image_name='raw'):
#         self.cell_channels = self.channel_metadata.loc[self.channel_metadata['cell_segment'] == 1, 'plot_channel']
#         img_idx = list(self.cell_channels.index)
#         self.cell_avg_channel = aggregate_images(
#             image_stack = self.images[image_name], 
#             img_idx=img_idx, 
#             agg_function='mean'
#         )
    
#     def nuclear_channel_img(self, image_name='raw'):
#         self.nuclear_channels = self.channel_metadata.loc[self.channel_metadata['nuclear_segment'] == 1, 'plot_channel']
#         img_idx = list(self.nuclear_channels.index)
#         self.nuclear_avg_channel = aggregate_images(
#             image_stack = self.images[image_name], 
#             img_idx=img_idx, 
#             agg_function='mean'
#         )
         
    def mesmer_input_img_fn(self):
        self.cell_channel_img()
        self.nuclear_channel_img()
        mesmer_img = np.stack(
            (self.nuclear_avg_channel, self.cell_avg_channel),
            axis =-1
        )
        self.mesmer_input_img = np.expand_dims(mesmer_img, 0)
        self.mesmer_input_RGB = create_rgb_image(
            self.mesmer_input_img, 
            channel_colors=['blue', 'green']
        )
        
    def mesmer_segment(self, postprocess_kwargs_whole_cell=None, postprocess_kwargs_nuclear=None):
        self.mesmer_input_img_fn()                
        print('pixel size: ', self.sample_metadata['step_um'])
        app_mes = Mesmer()
               
        #postprocess_kwargs_whole_cell = {'small_objects_threshold': 50}
        self.masks['mesmer_cell_mask'] = app_mes.predict(
            self.mesmer_input_img, 
            image_mpp=float(self.sample_metadata['step_um']), 
            compartment='whole-cell', 
            postprocess_kwargs_whole_cell=postprocess_kwargs_whole_cell,
            postprocess_kwargs_nuclear=postprocess_kwargs_nuclear,
            #postprocess_kwargs_whole_cell = postprocess_kwargs_whole_cell
        )[0, :, :, 0] 
        self.masks['mesmer_nuclei_mask'] = app_mes.predict(
            self.mesmer_input_img, 
            image_mpp=float(self.sample_metadata['step_um']), 
            compartment='nuclear',
            postprocess_kwargs_whole_cell=postprocess_kwargs_whole_cell,
            postprocess_kwargs_nuclear=postprocess_kwargs_nuclear,
        )[0, :, :, 0] 
               
    def mesmer_input_plot(self):
        fig, axs = plt.subplots(1, 3, figsize=(6, 2), dpi=50, constrained_layout=True)
        axs[0].imshow(self.nuclear_avg_channel, cmap = 'gray')
        axs[1].imshow(self.cell_avg_channel, cmap = 'gray')
        axs[2].imshow(self.mesmer_input_RGB[0, :, :, :])
        axs[0].set_title(f'Nuclei channel')
        axs[1].set_title(f'Membrane channel')
        axs[2].set_title('Merge')   
        fig.suptitle(f"{(self.sample_metadata['sample_name'])}")

        for ax in axs.flatten():
            ax.axis('off')
            scalebar = ScaleBar(
                self.sample_metadata['step_um'], 
                "um", 
                #fixed_value=200, 
                location='lower right', 
                width_fraction=0.02, 
                color='white', scale_loc='top',
                box_alpha=0.5, box_color='black')
            ax.add_artist(scalebar)
        plt.show()
        
    def mesmer_output_plot(self, out_dir=None):
        cell_mask_mesmer = np.expand_dims(self.masks['mesmer_cell_mask'], [0, -1])
        nucl_mask_mesmer = np.expand_dims(self.masks['mesmer_nuclei_mask'], [0, -1]) 
        
        overlay_cell = make_outline_overlay(
            rgb_data=self.mesmer_input_RGB, 
            predictions=cell_mask_mesmer
        )
        overlay_nuclei = make_outline_overlay(
            rgb_data=self.mesmer_input_RGB, 
            predictions=nucl_mask_mesmer
        )

        cmap_cell = rand_cmap(
            len(np.unique(self.masks['mesmer_cell_mask'])), 
            type='bright', 
            first_color_black=True, 
            last_color_black=False, 
            verbose=False
        )
        cmap_nucl = rand_cmap(
            len(np.unique(self.masks['mesmer_nuclei_mask'])), 
            type='bright', 
            first_color_black=True, 
            last_color_black=False, 
            verbose=False
        )

        fig, axs = plt.subplots(
            2, 3, 
            figsize=(9, 6), 
            dpi=80, 
            constrained_layout=True
        )
        axs[0, 0].imshow(self.cell_avg_channel, cmap = 'gray')
        axs[1, 0].imshow(self.nuclear_avg_channel, cmap = 'gray')
        axs[0, 1].imshow(overlay_cell[0, ...])
        axs[1, 1].imshow(overlay_nuclei[0, ...])

        axs[0, 2].imshow(self.masks['mesmer_cell_mask'], cmap=cmap_cell)
        axs[1, 2].imshow(self.masks['mesmer_nuclei_mask'], cmap=cmap_nucl)

        axs[0, 0].set_title(f'Membrane channel')
        axs[1, 0].set_title(f'Nuclei channel')
        axs[0, 1].set_title('Cell prediction overlay')
        axs[1, 1].set_title('Nuclei prediction overlay')
        axs[0, 2].set_title('Cell prediction labels')
        axs[1, 2].set_title('Nuclei prediction labels')
        fig.suptitle(f"{(self.sample_metadata['sample_name_ref'])}")
        
        for ax in axs.flatten():
            ax.axis('off')
            scalebar = ScaleBar(
                self.sample_metadata['step_um'], 
                "um", 
                #fixed_value=200, 
                location='lower right', 
                width_fraction=0.02, 
                color='white', scale_loc='top',
                box_alpha=0.5, box_color='black')
            ax.add_artist(scalebar)
            
        if isinstance(out_dir, pathlib.Path):
            save_name = out_dir / f'{self.sample_metadata["sample_name_ref"]}_mesmer_output.png'
            plt.savefig(save_name, dpi=300)            
        plt.show()
        
    def cell_nuclei_match(
        self, 
        cell_mask='mesmer_cell_mask', 
        nuclei_mask='mesmer_nuclei_mask', 
        jaccard_threshold=0.4
    ):
        cell_mask = self.masks[cell_mask]
        nuclei_mask = self.masks[nuclei_mask]
                
        matched_cell_mask = np.zeros(cell_mask.shape)
        matched_nuclei_mask = np.zeros(nuclei_mask.shape)

        for cell_id in np.unique(cell_mask)[1:]: # ignore 0 for background
            cell_id_mask = cell_mask == cell_id

            # Score nuclei labels that overlap a cell mask labels
            cell_id_matched_nuclei = np.unique(nuclei_mask[cell_id_mask])[1:]
            overlap_scores = {}
            for nuclei_id in cell_id_matched_nuclei:
                nuclei_id_mask = nuclei_mask == nuclei_id
                overlap_scores[nuclei_id] = jaccard_score(
                    cell_id_mask, 
                    nuclei_id_mask, 
                    average='micro'
                )

            # Carry matched cell IDs and nuclei IDs over matched threshold into 
            # a matched mask with the same integer value
            if not bool(overlap_scores): # check if any overlap
                pass
            else: 
                if max(overlap_scores.values()) > jaccard_threshold:
                    max_score_key = max(overlap_scores, key=overlap_scores.get)
                    nuclei_id_mask = nuclei_mask == max_score_key
                    matched_cell_mask[cell_id_mask] = cell_id
                    matched_nuclei_mask[nuclei_id_mask] = cell_id
                else: 
                    pass

        # Checking if matched ids in cell or nuclei
        for cell_id in np.unique(matched_cell_mask)[1:]:
            if cell_id not in np.unique(matched_nuclei_mask):
                matched_cell_mask[matched_cell_mask == cell_id] = 0

        for nuclei_id in np.unique(matched_nuclei_mask)[1:]:
            if nuclei_id not in np.unique(matched_cell_mask):
                matched_nuclei_mask[matched_nuclei_mask == cell_id] = 0

        if set(np.unique(matched_cell_mask)) == set(np.unique(matched_nuclei_mask)):
            pass
        else:
            print('cell and nuclei mask mismatched!!!')

        # Create non nuclei mask
        matched_non_nuclei_mask = matched_cell_mask.copy()
        matched_non_nuclei_mask[matched_nuclei_mask > 0] = 0
        
        non_nuc_ids = set(np.unique(matched_non_nuclei_mask))
        nuc_ids = set(np.unique(matched_non_nuclei_mask))
        cell_ids = set(np.unique(matched_cell_mask))

        # Check for unmatched non_nuc_ids 1
        #print(len(non_nuc_ids), len(nuc_ids), len(cell_ids))
        if len(non_nuc_ids) != len(nuc_ids):
            unmatched_ids = nuc_ids - non_nuc_ids
            #print('non_nuc_ids not in nuc_ids', unmatched_ids)
            
            for unmatched_id in unmatched_ids:
                matched_cell_mask[matched_cell_mask == unmatched_id] = 0
                matched_nuclei_mask[matched_nuclei_mask == unmatched_id] = 0
                matched_non_nuclei_mask[matched_non_nuclei_mask == unmatched_id] = 0
            
        # Check for unmatched non_nuc_ids 2
        if len(non_nuc_ids) != len(cell_ids):
            unmatched_ids = cell_ids - non_nuc_ids
            #print('non_nuc_ids not in cell_ids', unmatched_ids)
            
            for unmatched_id in unmatched_ids:
                matched_cell_mask[matched_cell_mask == unmatched_id] = 0
                matched_nuclei_mask[matched_nuclei_mask == unmatched_id] = 0
                matched_non_nuclei_mask[matched_non_nuclei_mask == unmatched_id] = 0

        assert set(np.unique(matched_cell_mask)) == set(np.unique(matched_nuclei_mask))
        assert set(np.unique(matched_nuclei_mask)) == set(np.unique(matched_non_nuclei_mask))
        
        self.masks['matched_cell_mask'] = matched_cell_mask
        self.masks['matched_nuclei_mask'] = matched_nuclei_mask
        self.masks['matched_non_nuclei_mask'] = matched_non_nuclei_mask
        
        print('matched_cell_mask', len(np.unique(matched_cell_mask)))
        print('matched_nuclei_mask', len(np.unique(matched_nuclei_mask)))
        print('matched_non_nuclei_mask', len(np.unique(matched_non_nuclei_mask)))
        
    def segmented_masks_plot(self, out_dir=None):        
        masks = [name for name in self.masks if name != 'fpico_mask']
        
        fig, axs = plt.subplots(
            nrows=len(masks)%3, 
            ncols=3, 
            figsize=(3*3,len(masks)%3*3), 
            dpi=80, 
            constrained_layout=True
        )
        
        for i, mask in enumerate(masks):
            cmap = rand_cmap(
                len(np.unique(self.masks[mask])), 
                type='bright', 
                first_color_black=True, 
                last_color_black=False, 
                verbose=False
            )

            axs.flatten()[i].imshow(self.masks[mask], cmap=cmap)
            axs.flatten()[i].set_title(mask)
        
        for ax in axs.flatten():
            ax.axis('off')

        for i in range(len(masks)):
            scalebar = ScaleBar(
                self.sample_metadata['step_um'], 
                "um", 
                #fixed_value=200, 
                location='lower right', 
                width_fraction=0.02, 
                color='white', scale_loc='top',
                box_alpha=0.5, box_color='black')
            axs.flatten()[i].add_artist(scalebar)
            
        fig.suptitle(f"{(self.sample_metadata['sample_name_ref'])}")
        
        if isinstance(out_dir, pathlib.Path):
            save_name = out_dir / f'{self.sample_metadata["sample_name_ref"]}_masks.png'
            plt.savefig(save_name, dpi=300)
            
        plt.show()
        
    def export_masks_to_source_hdf(self):
        with h5py.File(self.fpath, 'r+') as hdf:    
            for mask in self.masks:
                mask_sub_node = f'masks/{mask}'
                if mask_sub_node in hdf:
                    hdf[mask_sub_node][...] = self.masks[mask]
                if mask_sub_node not in hdf:
                    hdf.create_dataset(
                        mask_sub_node, 
                        data=self.masks[mask].astype(int), 
                        compression='gzip'
                    )
                    
    def image_mask_feature_measure(self, image_n, mask_n):
        mask = self.masks[mask_n].astype(int)
        images = self.images[image_n]   
        
        df_select_channels = self.channel_metadata[self.channel_metadata['shortname'] != 'nan']
        select_channels = df_select_channels.index
        images = images[:, :, select_channels]
        channel_names = list(df_select_channels['plot_channel'])
       
        df_measures = measure_intensites(
            img = np.moveaxis(images, -1, 0),
            mask = mask,
            channel_names = channel_names,
            measurement = Measurement.MEAN,
        )
        df_measures.index = df_measures.index.astype(str)

        df_region = measure_regionprops(
            img = np.moveaxis(images, -1, 0),
            mask = mask,
            skimage_regionprops = [
                'label', 'centroid', 'orientation', 'major_axis_length', 
                'minor_axis_length', 'area', 'eccentricity', 'eccentricity', 
                'perimeter'
            ]
        )
        df_region.index = df_region.index.astype(str)
                             
        adata = ad.AnnData(X=df_measures.values, obs=df_region)
        adata.obs['label_id'] = df_region.index

        adata.var_names = channel_names
        adata.var['shortname'] = list(df_select_channels['shortname'])
        
        channel_longnames = [i + ' | ' +  j for i, j in (zip(list(adata.var_names), list(adata.var['shortname'])))]
        adata.var['longname'] = channel_longnames

        adata.obs['sample_name_ref'] = self.sample_metadata['sample_name_ref']
        adata.obs['step_um'] = self.sample_metadata['step_um']
        adata.obs['AB_panel'] = self.sample_metadata['AB_panel']
        adata.obs['hph_mask_key'] = mask_n
        adata.obs['hph_image_key'] = image_n

        return adata
    
    def mask_graph_calculate(self, mask_n):
        print(mask_n)
        
        
    def export_hdf(self, output_fpath):
        with h5py.File(output_fpath, 'a') as hdf:
            # images exported as 3D stack [x, y, c]
            images_node = 'images'
            hdf.require_group(images_node)
            for image in self.images:
                image_sub_node = f'{images_node}/{image}'
                if image_sub_node in hdf:
                    hdf[image_sub_node][...] = self.images[image]
                if image_sub_node not in hdf:
                    hdf.create_dataset(image_sub_node, data=self.images[image], compression='gzip')

            # masks exported as 2D array [x, y]
            masks_node = 'masks'                
            hdf.require_group(masks_node)    
            if self.masks == None:
                pass
            if isinstance(self.masks, dict):
                for mask in self.masks:
                    mask_sub_node = f'{masks_node}/{mask}'
                    if mask_sub_node in hdf:
                        hdf[mask_sub_node][...] = self.masks[mask]
                    if mask_sub_node not in hdf:
                        hdf.create_dataset(mask_sub_node, data=self.masks[mask], compression='gzip')

            # sample_metadata exported as attributes
            if self.sample_metadata == None:
                pass
            else:
                for sample_data in self.sample_metadata.keys():
                    if self.sample_metadata[sample_data] is not None:
                        if sample_data in hdf:
                            hdf[sample_data][...] = self.sample_metadata[sample_data]                
                        if sample_data not in hdf:
                            hdf.create_dataset(sample_data, data=self.sample_metadata[sample_data])
                                
        # dataframe of channel information exported with pandas standard hdf export function
        if f'{images_node}/df_channel_metadata' not in h5py.File(output_fpath, 'r'):
            self.channel_metadata.to_hdf(output_fpath, f'{images_node}/df_channel_metadata', mode='a')
                
def adata_reindex(adata, prefix):
    reindex = ['-'.join([str(prefix), i]) for i in adata.obs.index.to_list()]
    adata.obs.index = reindex    
    return adata    

def multiple_hph_to_adata(hdf_filepaths, image_n, mask_n):
    for i, hdf_fpath in enumerate(hdf_filepaths):
        if i == 0:
            hdf_segment = hdf_to_HighPlex_Hdf(hdf_fpath)
            adata = hdf_segment.image_mask_feature_measure(
                image_n=image_n, 
                mask_n=mask_n
            )    
            adata = adata_reindex(adata, i)
            
            hph_id = hdf_segment.sample_metadata['sample_name_ref']
            adata.uns['high_plex_hdf_paths'] = {hph_id:list(hdf_fpath.parts)}
            adata.obs['hph_id'] = hph_id

        else:
            hdf_segment = hdf_to_HighPlex_Hdf(hdf_fpath)
            adata_nth = hdf_segment.image_mask_feature_measure(
                image_n=image_n, 
                mask_n=mask_n
            )    
            adata_nth = adata_reindex(adata_nth, i)
            
            hph_id = hdf_segment.sample_metadata['sample_name_ref']
            adata_nth.uns['high_plex_hdf_paths'] = {hph_id:list(hdf_fpath.parts)}
            adata_nth.obs['hph_id'] = hph_id

            adata = ad.concat(
                [adata, adata_nth],
                merge="same", # carries through joining of variables
                uns_merge="unique", # seperates uns image metadata per merged adata object
                join='inner'
            )    
    return adata

def multiple_hph_channel_plot(hdf_filepaths, channel):
    for i, hdf_fpath in enumerate(hdf_filepaths):
        if i == 0:
            print(i)
        else:
            print(i) 
    return adata
                    
